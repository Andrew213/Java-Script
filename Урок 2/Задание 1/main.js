// debugger;


// function getNum(string) {
//   const n = prompt(string);
//   if (!isNaN(parseFloat(n)) && isFinite(n)) {
//     return parseFloat(n);
//   } else if (n === null) {
//     alert("Уже уходишь?");
//     return;
//   } else {
//     alert("Введены не корректные данные");
//     return getNum(string);
//   }

// }

// Функции могут быть в области видимости, когда они уже определены, но функции вида "function declaration statment" могут быть подняты 



// function compareNumbers() {
//   const a = getNum("Введите первое число");
//   const b = getNum("Введите второе число");
//   if (a && b) {
//     if (a > b) {
//       alert("Первое число больше второго");
//     } else if (b > a) {
//       alert("Второе число больше первого");
//     } else if (a === b) {
//       alert("Числа равны");
//     }
//   }
// }

// compareNumbers();






//Function Expression
// Стрелочные функции всегда анонимны.

let getNum = string => {
  const n = prompt(string);
  if (!isNaN(parseFloat(n)) && isFinite(n)) {
    return parseFloat(n);
  } else if (n === null) {
    alert("Уже уходишь?");
    return;
  } else {
    alert("Введены не корректные данные");
    return getNum(string);
  }
};

alert(getNum());
//  в Function Expression ставится точка с запятой ; на конце

// let age = prompt("Сколько Вам лет?", 18);

// let welcome = (age < 18) ?
//   () => alert('Привет') :
//   () => alert("Здравствуйте!");

// welcome();



// Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться.
//Функции вида "function expression" удобны, когда функция передается аргументом другой функции.
// let x = square(4);
// console.log(x)
// let square = function (number) {
//   return number * number;
// };


// x получает значение 16


//Function Declaration можно использовать во всем скрипте (или блоке кода, если функция объявлена в блоке).

//Если параметр не указан, то его значением становится undefined.
// В JavaScript параметры по умолчанию вычисляются каждый раз, когда функция вызывается без соответствующего параметра.

// function compareNumbers( a = "значение оп умолчанию") {
//   const a = getNum("Введите первое число");
//   const b = getNum("Введите второе число");
//   if (a && b) {
//     if (a > b) {
//       alert("Первое число больше второго");
//     } else if (b > a) {
//       alert("Второе число больше первого");
//     } else if (a === b) {
//       alert("Числа равны");
//     }
//   }
// }

// function A() {
//   let title = 'internal';
//   alert(title);
// }
// A();


// После того, как функция A будет выполнена, переменная title перестанет существовать и к ней никак нельзя получить доступ. 
//Попытка как-либо обратиться к переменной вызовет ошибку, что переменная не была объявлена.


// function getTitle() {
//   let title = "default title";
//   let showTitle = function () {
//     alert(title);
//   };
//   let setTitle = function (newTitle) {
//     title = newTitle;
//   };
//   return {
//     "showTitle": showTitle,
//     "setTitle": setTitle
//   };
// }
// let t = getTitle();
// t.showTitle();
// t.setTitle("Hello World");
// t.showTitle();
// Вложенная функция имеет доступ ко всем инструкциям внешней функции.
// Вложенная функция может использовать аргументы и переменные внешней функции, в то время как внешняя функция не может использовать аргументы и переменные вложенной функции.

// var foo = function bar() {
//   тело функции
//   Внутри функции (function body) //все следующие вызовы эквивалентны:
//   1 - bar()
//   2 - arguments.callee()
//   3 - foo()

// };

// function A(x) {
//   function B(y) {
//     function C(z) {
//       console.log(x + y + z);  //Более вложенный scope имеет приоритет, так самый вложенный scope имеет наивысший приоритет, и наоборот. 
//     }
//     C(3);
//   }
//   B(2);
// }
// A(1); // в консоле выведится 6 (1 + 2 + 3)


// В обратном порядке, однако, это не верно. 
// A не имеет доступ к переменным и аргументам C, потому что A не имеет такой доступ к B. Таким образом, C остается приватным только для B.

// -----------------РЕКУРСИЯ

// Максимальная глубина рекурсии ограничена движком JavaScript. Точно можно рассчитывать на 10000 вложенных вызовов,



// некоторые алгоритмы не могут быть простыми повторяющимися циклами. 
// Например, получение всех элементов структуры дерева (например, DOM) проще всего реализуется использованием рекурсии

// Рекурсивное решение обычно короче
// Рекурсивное решение задачи обычно короче, чем итеративное.
// Рекурсия приводит к хранению всех данных для неоконченных внешних вызовов в стеке
// Любая рекурсия может быть переделана в цикл. Как правило, вариант с циклом будет эффективнее.
// Часто код с использованием рекурсии более короткий, лёгкий для понимания и поддержки. 
// Оптимизация требуется не везде, как правило, нам важен хороший код, поэтому она и используется.

// let num1 = 20,
//   num2 = 3,
//   name = 'Chamahk';

// function multiply() {
//   return num1 * num2;
// }

// multiply(); // вернет 60

// Пример вложенной функции
// function getScore() {
//   let num1 = 2,
//     num2 = 3;

//   function add() {
//     return name + ' scored ' + (num1 + num2);
//   }

//   return add();
// }

// getScore(); // вернет "Chamahk scored 5"


// РЕКУРСИЯ